import { useState, useCallback } from "react";
import { LoadingIndicator, Page } from "components/core";
import SurveyPage from "components/shared/SurveyPage";
import { navigate } from "@reach/router";
import { decode } from "services/instance-id";
import {
  requestParticipantProgress,
  useParticipantProgress,
} from "api/survey-instances";
import Error from "./Error";
import { useLocalInstances } from "app/contexts/LocalInstances";
import { logParticipantEvent } from "api/participant-event-logs";
import ParticipantIdEntry from "./ParticipantIdEntry";
import ErrorBoundary from "components/ErrorBoundary";
import SurveyNotFoundError, { errorCallToAction } from "./SurveyNotFoundError";
import { useQueryString } from "hooks/useQueryString";
import Preview from "./Preview";

// Do all the data fetching and validation ahead of rendering the survey
const SurveyBootstrapper = ({ id: friendlyId }) => {
  // can opt into preview mode from query string
  const { preview: isPreview } = useQueryString();

  // we can lookup in progress participant Id's
  // to resume without prompting user for id
  const { instances, storeInstanceParticipantId } = useLocalInstances();

  const [surveyId] = decode(friendlyId);
  const { data: progress, mutate } = useParticipantProgress(
    friendlyId,
    instances[friendlyId]
  );

  console.log(progress);

  // behave differently based on progress state
  /* Valid Progress matrix
   *
   *   Page | Known ID | New ID | Output
   *   ---------------------------------
   *     Y  |    Y     |    N   | (Update ID) and Load Page
   *     N  |    Y     |    N   | Survey complete and not repeatable
   *     N  |    N     |    N   | Interactive ID entry required
   *     Y  |    N     |    Y   | Update ID and Load Page - autogenerated ID
   *     Y  |    Y     |    Y   | Update ID and Load Page - Survey complete and repeatable
   */

  // TODO: NotFound? return <SurveyNotFoundError />;

  // Empty Survey
  if (!progress.pageCount)
    return (
      <Error
        message={"That Survey contains no pages."}
        callToAction={errorCallToAction}
      />
    );

  // Interactively get Participant Id
  if (!progress.participantId && !progress.newParticipantId)
    return (
      <ParticipantIdEntry
        combinedId={friendlyId}
        // TODO: server side valid identifier check
      />
    );

  // Survey Complete
  if (progress.participantId && !progress.page) {
    navigate(`/survey/${friendlyId}/complete`);
    return null;
  }

  // Valid Survey Progress
  if (progress.page) {
    storeInstanceParticipantId(
      friendlyId,
      progress.newParticipantId ?? progress.participantId
    );

    if (isPreview) return <Preview id={surveyId} />;

    return (
      <Survey
        friendlyId={friendlyId}
        participantId={progress.newParticipantId ?? progress.participantId}
        progress={progress}
        mutateProgress={mutate}
      />
    );
  }

  // Any reason we're still here?
  return <LoadingIndicator />;
};

// TODO: move the callbacks out to static methods in the survey-bootstrap service
const Survey = ({ friendlyId, participantId, progress, mutateProgress }) => {
  const { clearInstanceParticipantId } = useLocalInstances();
  const [isBusy, setIsBusy] = useState();

  const [surveyId, instanceId] = decode(friendlyId);

  const logEvent = useCallback(
    async (source, type, payload) => {
      await logParticipantEvent(
        instanceId,
        participantId,
        source,
        type,
        payload
      );
    },
    [instanceId, participantId]
  );

  const handleClick = async () => {
    // TODO confirm modal? if (progress.isLastPage)
    setIsBusy(true);
    try {
      // 1. POST navigation request
      const { progress } = await requestParticipantProgress(
        friendlyId,
        participantId,
        "next"
      );
      // 2. Handle response
      if (!progress.page) {
        // no next page provided; triggers survey completion
        // server already logged the completion event
        // so we should empty stored participant ids if necessary
        // and navigate to the correct completion url

        // the decsys completion page also does this, for safety
        // but we should do it here too for surveys with custom completion URLs
        if (progress.useParticipantIdentifiers)
          clearInstanceParticipantId(friendlyId);

        navigate(
          progress.settings?.CompletionUrl ?? `/survey/${friendlyId}/complete`
        );
      } else {
        // progress; just mutate our local progress and proceed
        mutateProgress();
      }
    } catch (e) {
      console.error(e);
    }
    setIsBusy(false);
  };

  return (
    <Page layout="survey">
      <SurveyPage
        surveyId={surveyId}
        page={progress.page}
        lastPage={progress.isLastPage}
        handleNextClick={handleClick}
        logEvent={logEvent}
        isBusy={isBusy}
      />
    </Page>
  );
};

// Wrap everything in an error boundary,
// to catch errors from getting the instance via SWR (404, 400...)
const SurveyWrapper = ({ id }) => (
  <ErrorBoundary fallback={<SurveyNotFoundError />}>
    <SurveyBootstrapper id={id} />
  </ErrorBoundary>
);

export default SurveyWrapper;
